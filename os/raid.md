# RAID

RAID(Redundant Array of Independent Disk)는 그 이름에서 알 수 있듯, 여러 개의 디스크를 이용하여 하나의 큰 디스크를 사용하는 것 보다 속도, 안정성, 효율성, 가용성을 높히는 데 사용되는 기술이다.

서버를 운영하면서 겪는 어려움 중 하나는 하드디스크의 수명이 다함으로 인해 data가 손실되는 문제이다. 서버 특성상 I/O가 많이 일어나기 때문에 잦은 고장은 피할 수 없다. 때문에, RAID 구성을 통해서 서버 디스크의 안정성과 성능 등을 향상시킬 수 있다.

## 장점

* 데이터 안정성 향상
* 디스크 증설의 용이
* 디스크의 IO 성능 향상

## 종류

### 1. RAID 0
RAID 0에는 Concatenate, Stripe 방식 두 가지가 있다.

* Concatenate 방식
Concateante 방식은 두 개 이상의 디스크에 순차적으로 데이터를 쓰는 방법이다. 때문에 디스크의 공간이 부족하면 기존의 데이터를 보존하면서 여분의 디스크를 볼륨에 포함하여 디스크의 총 용량을 늘릴 수 있다. 하지만, 구성된 디스크 중 하나라도 문제가 발생하면 복구가 힘들고, **Parity**를 지원하지 않는다.

![raid0](/image/raid-0.png)

* Stripe 방식
흔히 이 Stripe방식을 RAID 0이라고 하며, 두 개 이상의 디스크에 데이터를 랜덤하게 쓰는 방식이다. 데이터를 사용할 때 I/O를 디스크 수 만큼 분할하여 쓰기 때문에 I/O의 속도가 향상되며 I/O Controller가 별도로 장착된 경우에는 더 큰 속도 향상이 가능하다. 하지만, Stripe를 구성할 시 기존 데이터를 모두 삭제해야하며, Concatenate에서의 문제와 같은 문제가 발생한다.

### 2. RAID 1 (Mirror)

![raid1](/image/raid-1.png)

적어도 두 개 이상의 (동일한 크기의) 디스크에 같은 데이터를 중복으로 기록하는 방식이다. 때문에 구성 디스크 중 하나만 정상이라면 데이터가 보존되어 운영이 가능하다. 또한 복원이 비교적 간단하다. 하지만 전체 용량에 비해 실제 저장하는 데이터의 양은 줄어들고, 여러 디스크에 같은 데이터를 써야한다는 단점이 있다. 또한 패리티를 지원하지 않는다.

### 3. RAID 2

![raid2](/image/raid-2.png)
**RAID 0**와 같은 Striping 방식이다. 하지만 **Hamming code**를 사용하여 에러 체크 및 수정이 가능하다. 하지만 하드디스크에서는 ECC(Error Correction Code)를 지원하지 않기 때문에 ECC를 별도의 드라이브에 저장하는 방식으로 처리한다. 때문에 ECC가 저장된 디스크가 손상되면 문제가 발생할 수 있고, 패리티를 하나의 디스크에 저장하는 **RAID 4가 등장하면서 거의 사용되지 않는 방식이다.**

### 4. RAID 3, RAID 4

![raid3-4](/image/raid-3-4.png)
RAID 0, RAID 1의 문제점을 보완하기 위해 고안된 방법이며, RAID 0과 같은 Striping 구성을 한다. 때문에 디스크 성능을 보안하고 전체 용량을 온전히 사용할 수 있다. 여기에, 패리티 정보를 별도의 디스크에 따로 저장한다. 3, 4의 차이점은 다음과 같다. RAID 3은 데이터를 바이트 단위로 나누어 동등하게 분산 기록하며 RAID 4는 데이터를 블록단위로 기록한다는 차이가 있다. 또한 RAID 3은 드라이브간 동기화가 필수적이고, RAID 4는 그렇지 않다고 한다. (둘 중에서는 RAID 4를 더 많이 사용한다고 함.)

패리티 정보 기록을 위한 디스크를 제외한 나머지 디스크를 모두 스트라이핑으로 사용하므로 저장 용량에서 유리하고, 패리티 정보를 별도의 디스크에 저장하기 때문에 스트라이핑 디스크 중 고장난 디스크가 있어도 이 값을 통해 복구할 수 있다. 그러나 패리티 디스크에 문제가 생기면 문제가 커진다.

스트라이핑 방식과 달리 패리티 정보를 저장하거나 복구할 때 XOR연산이 필요하고, 때문에 고가의 RAID 컨트롤러는 XOR 연산을 담당하는 프로세서가 따로 장착되어있다.

### 5. RAID 5

![raid5](/image/raid-5.png)
RAID 5는 RAID 3, 4에서 별도의 패리티 디스크를 사용하여 발생하는 문제를 보완하기위해 패리티 정보를 스트라이핑으로 구성된 디스크 내에서 처리하도록 만들었다. 패리티 정보는 데이터가 저장된 디스크와 물리적으로 다른 디스크에 저장하여 하나의 디스크가 고장나더라도 남은 디스크를 통해 복구할 수 있다. RAID 5를 구성하기 위해서는 최소 3개 이상의 디스크를 사용하여야 하며 전체 디스크 용량은 하나의 디스크 용량 * (N-1)이 된다. 따라서 RAID 1에 비해 저장공간도 크면서 패리티 기능을 지원한다.

패리티 정보와 관련된 데이터간 저장되는 디스크가 다르기 때문에, 위의 그림에서 Disk 1이 문제가 생기면 A1, B1, C1 데이터는 다른 디스크의 패리티 정보를 통해 복구할 수 있다. 또한 D에 대한 패리티 정보는 나머지 디스크의 D1, D2, D3를 통해 다시 복구할 수 있다. 때문에 RAID 3, 4와 비교할 때 패리티 디스크 고장과 같은 문제에서 자유롭다. RAID 5는 실제 가장 많이 사용되는 방식 중 하나이다. 하지만, 한 번에 여러 디스크에 문제가 생기는 경우 복구하기 힘들다. 

RAID3, 4와 같은 이유로 RAID 5 역시 XOR 연산을 필요로 한다.

### 6. RAID 6

![raid-6](/image/raid-6.png)
RAID 6은 RAID 5와 거의 유사하다. 다른 점은 2차 패리티 정보를 넣어서 2개의 디스크에 문제가 생겨도 데이터를 복구할 수 있다. 이론상 3개 이상의 디스크부터 RAID 6을 구성할 수 있지만 이런 경우 하나의 디스크에 저장될 데이터에 대한 패리티 정보를 두 개의 디스크에 저장하는 꼴이 되므로 전체 용량의 1/3만 사용 가능하다. 그래서 보통 RAID 6을 구성할 때에는 4개 이상의 디스크로 구성하며 RAID 5보다 안정성을 고려해야되는 시스템에서 사용한다.

위의 그림을 보면, 40GB 디스크 4개로 RAID 6을 구성하였다. 이 때 패리티 정보를 저장하기 위해 80GB. 즉, 디스크 2개에 패리티 정보를 저장하기 때문에 실제 사용 가능한 옹량은 절반밖에 되지 않는다. 하지만 스트라이핑 방식으로 성능도 비교적 좋고 안정성도 높다. 하지만 RAID 5와 비교할 때 특히 쓰기 구현이 복잡하여 자주 쓰지는 않는 방법이다.

### 7. RAID 0+1
