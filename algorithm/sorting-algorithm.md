# Sorting Algorithm

## Sorting algorithm 이란?
Sorting algorithm은, 말 그대로 n개의 정렬 가능한 개체들에 대해서 특정한 기준에 맞게 정렬하는 알고리즘이다. 정렬을 위해서는 각 개체간 대소 비교를 할 수 있어야 하므로 일반적으로 정렬 대상은 숫자라고 생각하면 된다.

정렬 방법은 매우 다양한데, 이에 따라서 각각의 수행시간도 다르고 경우에 따라 알고리즘을 위해 추가적인 공간을 필요로 하기도 한다.

그럼 지금부터, sorting algorithm을 하나하나 살펴보며 알아보도록 하자.

## Selection Sort (선택 정렬)

selection sort는 이름에서 알 수 있듯이, 무언가를 선택하여 수행하는 알고리즘이겠구나 라고 추측할 수 있다. 이 알고리즘은, 현재 위치에 들어갈 값을 찾고, 이를 통해서 정렬을 한다.

기본적인 로직은 다음과 같다.
1. 주어진 배열의 맨 앞에 있는 index를 포함하여 이후의 index에 있는 배열의 값 중에서 가장 작은 값을 찾는다.
2. 가장 작은 값을 현재 index의 배열값과 바꾼다.
3. 다음 index에서 위의 과정을 반복한다.

이 sorting algorithm은 n개의 element를 가지는 배열에 대해서, (n-1), (n-2), ... , 1개씩 반복하여 비교한다. 배열이 심지어 정렬이 되있더라도 이러한 비교가 이루어지므로 O(n^2)의 시간복잡도를 가지게 된다.

공간 복잡도의 경우, 추가적인 자료구조가 필요하지 않으므로 주어진 배열의 크기에 대한 O(n)이다.

## Insertion Sort (삽입 정렬)

Insertion sort는 현재 index에서, 그 앞에 있는 index에 해당하는 element값과 비교하여 들어갈 위치를 찾고, 해당 위치에 값을 삽입하는 알고리즘이다.

기본적인 로직은 다음과 같다.

1. Insertion sort는 두 번째 인덱스부터 시작한다. 현재 index는 별도의 변수에 저장해두고, 비교할 index를 현재 index-1로 둔다.
2. 별도로 저장한, 즉 insertion을 위한 값과 비교할 index에 해당하는 element 값을 비교한다.
3. insertion값이 더 작으면, 현재 인덱스로 비교할 element값을 저장, 비교 index를 -1하여 반복한다.
4. insertion 값이 더 크면, 비교 index + 1에 insertion값을 저장한다.

이 알고리즘은 역으로 정렬되어있을 때가 최악의 경우로, O(n^2)이지만 이미 정렬된 경우 한 번씩만 비교하기 때문에 O(n)이다. 하지만 Big-O notation은 상한을 기준으로 하므로 O(n^2)이다.

공간 복잡도는 하나의 배열에서 진행하므로 O(n)이다.

버블 소트, 퀵소트, 머지 소트는 내일 추가할 예정.
