# Sorting Algorithm

## Sorting algorithm 이란?
Sorting algorithm은, 말 그대로 n개의 정렬 가능한 개체들에 대해서 특정한 기준에 맞게 정렬하는 알고리즘이다. 정렬을 위해서는 각 개체간 대소 비교를 할 수 있어야 하므로 일반적으로 정렬 대상은 숫자라고 생각하면 된다.

정렬 방법은 매우 다양한데, 이에 따라서 각각의 수행시간도 다르고 경우에 따라 알고리즘을 위해 추가적인 공간을 필요로 하기도 한다.

그럼 지금부터, sorting algorithm을 하나하나 살펴보며 알아보도록 하자.

## Selection Sort (선택 정렬)

selection sort는 이름에서 알 수 있듯이, 무언가를 선택하여 수행하는 알고리즘이겠구나 라고 추측할 수 있다. 이 알고리즘은, 현재 위치에 들어갈 값을 찾고, 이를 통해서 정렬을 한다.

기본적인 로직은 다음과 같다.
1. 주어진 배열의 맨 앞에 있는 index를 포함하여 이후의 index에 있는 배열의 값 중에서 가장 작은 값을 찾는다.
2. 가장 작은 값을 현재 index의 배열값과 바꾼다.
3. 다음 index에서 위의 과정을 반복한다.

이 sorting algorithm은 n개의 element를 가지는 배열에 대해서, (n-1), (n-2), ... , 1개씩 반복하여 비교한다. 배열이 심지어 정렬이 되있더라도 이러한 비교가 이루어지므로 O(n^2)의 시간복잡도를 가지게 된다.

공간 복잡도의 경우, 추가적인 자료구조가 필요하지 않으므로 주어진 배열의 크기에 대한 O(n)이다.

## Insertion Sort (삽입 정렬)

Insertion sort는 현재 index에서, 그 앞에 있는 index에 해당하는 element값과 비교하여 들어갈 위치를 찾고, 해당 위치에 값을 삽입하는 알고리즘이다.

기본적인 로직은 다음과 같다.

1. Insertion sort는 두 번째 인덱스부터 시작한다. 현재 index는 별도의 변수에 저장해두고, 비교할 index를 현재 index-1로 둔다.
2. 별도로 저장한, 즉 insertion을 위한 값과 비교할 index에 해당하는 element 값을 비교한다.
3. insertion값이 더 작으면, 현재 인덱스로 비교할 element값을 저장, 비교 index를 -1하여 반복한다.
4. insertion 값이 더 크면, 비교 index + 1에 insertion값을 저장한다.

이 알고리즘은 역으로 정렬되어있을 때가 최악의 경우로, O(n^2)이지만 이미 정렬된 경우 한 번씩만 비교하기 때문에 O(n)이다. 하지만 Big-O notation은 상한을 기준으로 하므로 O(n^2)이다.

공간 복잡도는 하나의 배열에서 진행하므로 O(n)이다.

## Bubble Sort (버블 정렬)

Bubble sort는 매번 연속된 두 개의 인덱스 값에 해당하는 element의 값을 비교하여 작은 값을 앞으로, 큰 값을 뒤로 보내어 정렬하는 방법이다. (오름차순 정렬의 경우) 따라서 처음 한 번 이러한 과정을 수행하고 나면, 가장 큰 값이 맨 뒤에 저장된다. 그리고 다음에는 전체 배열의 크기에서 현재까지 순환한 횟수만큼만 반복해주면 된다.

기본적인 로직은 다음과 같다.

1. Bubble sort는 두 번째 인덱스부터 시작한다. 현재 인덱스와 다로 이전의 인덱스에 해당하는 element값을 비교한다.
2. 만약 이전의 값이 더 크면, 현재의 값과 바꾼다.
3. 현재 인덱스가 크면, 아무것도 하지 않는다.
4. 인덱스의 크기를 1 늘려준다.
5. 이를 전체 배열의 크기 - 현재 순환한 횟수만큼 반복한다

이 알고리즘은 selection sort와 마찬가지로 배열이 어떤 상태이건 전체 비교를 진행하므로 시간복잡도는 O(n^2)이다. 공간복잡도 역시 하나의 배열에서만 진행하므로 O(n)이다.

## Merge Sort (합병 정렬)

합병 정렬은 divide and conquer 방식으로 설계된 알고리즘이다. divide and conquer는 어떠한 문제를 나누어서 해결하는 방식인데, 여기서는 배열을 나눈 후에 Merge하는 방식을 택한다.

기본적인 로직은 다음과 같다.
1. 현재 배열을 반으로 나눈다. 배열의 시작 위치, 종료 위치를 각각 입력받고 둘을 더해 2로 나눈다. 이 값은 중간값으로 이를 기준으로 나누게 된다.
2. 이러한 방법을 통해서, 나누어진 배열의 크기가 0 혹은 1이 될때까지 반복한다.
3. 나누어진 두 배열 A,B의 크기를 비교한다. 각각의 배열에 대해서 현재 index를 i, j로 가정한다.
4. i에는 A배열의 시작 인덱스를 저장, j에는 B배열의 시작 인덱스를 저장한다.
5. A[i]와 B[j]를 비교한다. 오름차순의 경우 이 중에서 작은 값을 새 배열 C에 저장한다. A[i]가 더 크다면 A[i]를 배열 C에 저장해두고, i의 값을 하나 증가시켜준다.
6. 이를 i, j 둘 중 하나가 각 배열의 max index가 될 때 까지 반복한다.
7. 끝까지 저장 못한 배열의 값을 순서대로 C에 저장한다.
8. C를 원래 배열에 저장한다.

머지 과정에서는 A,B에 대한 정렬이 이루어지고, A배열의 크기를 n1, B배열의 크기를 n2라고 하면 O(n1+n2)가 된다. 즉 O(n)이 된다.

분할 과정은 Log(n)만큼 일어난다.

각 분할과정에 있어서 머지를 진행하므로, merge sort의 시간복잡도는 O(N * Log(n))이 된다. 사용하는 공간은 정렬을 위한 배열을 하나 더 생성하므로 2N개를 사용한다.
