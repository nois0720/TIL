# Sorting Algorithm

sorting은 컴퓨터 분야에서 중요한 문제 중 하나로 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 것이다. 실제로 컴퓨터 분야에서 사용하는 데이터의 경우, 숫자의 순서 혹은 어휘의 순서대로 정렬한 다음 사용해야 되는 경우가 많은 빈도로 발생하는데, 이것을 얼마나 효과적으로 해결할 수 있느냐가 이 문제의 핵심이라고 할 수 있다.

데이터를 정렬하는 이유 중 하나는 Search인데, 컴퓨터가 다루는 데이터는 일반적으로 우리가 생각하는 것 보다 훨씬 많다. 따라서 탐색할 대상의 데이터가 정렬되어있지 않다면 순차적으로 모든 데이터를 살펴보는 방법밖에 없다. 하지만 데이터가 정렬되어있다면 binary search라는 강력한 방법을 사용할 수 있다.

삽입과 삭제가 빈번히 일어나는 성격을 가진 데이터의 경우, 정렬에 더 많은 시간이 들어가므로 순차적으로 탐색하는 경우도 있지만, 대부분의 경우 삽입이나 삭제보다는 데이터를 찾는 횟수가 압도적으로 많고 이를 위해 필요한 것이 search이다.

이미 정렬된 데이터의 특징은 어떤 값을 임의로 선택하였을 때 해당 값을 기준으로 오른쪽에는 보다 큰 값이 존재하고, 왼쪽에는 보다 작은값이 존재한다는 것이다. 따라서 어떤 값을 선택하였을 때 찾고자 하는 값이 보다 작을땐 왼쪽, 반대의 경우 오른쪽을 찾으면 된다. binary search의 경우 O(logN)의 성능을 보여주는데 데이터의 수가 많아지면 압도적으로 성능이 높아지게 된다.

## Sorting algorithm 이란?
Sorting algorithm은, 말 그대로 n개의 정렬 가능한 개체들에 대해서 특정한 기준에 맞게 정렬하는 알고리즘이다. 정렬을 위해서는 각 개체간 대소 비교를 할 수 있어야 하므로 일반적으로 정렬 대상은 숫자라고 생각하면 된다.

정렬 방법은 매우 다양한데, 이에 따라서 각각의 수행시간도 다르고 경우에 따라 알고리즘을 위해 추가적인 공간을 필요로 하기도 한다.

그럼 지금부터, sorting algorithm을 하나하나 살펴보며 알아보도록 하자.

## Selection Sort (선택 정렬)

selection sort는 이름에서 알 수 있듯이, 무언가를 선택하여 수행하는 알고리즘이겠구나 라고 추측할 수 있다. 이 알고리즘은, 현재 위치에 들어갈 값을 찾고, 이를 통해서 정렬을 한다.

기본적인 로직은 다음과 같다.
1. 주어진 배열의 맨 앞에 있는 index를 포함하여 이후의 index에 있는 배열의 값 중에서 가장 작은 값을 찾는다.
2. 가장 작은 값을 현재 index의 배열값과 바꾼다.
3. 다음 index에서 위의 과정을 반복한다.

이 sorting algorithm은 n개의 element를 가지는 배열에 대해서, (n-1), (n-2), ... , 1개씩 반복하여 비교한다. 배열이 심지어 정렬이 되있더라도 이러한 비교가 이루어지므로 O(n^2)의 시간복잡도를 가지게 된다.

공간 복잡도의 경우, 추가적인 자료구조가 필요하지 않으므로 주어진 배열의 크기에 대한 O(n)이다.

## Insertion Sort (삽입 정렬)

Insertion sort는 현재 index에서, 그 앞에 있는 index에 해당하는 element값과 비교하여 들어갈 위치를 찾고, 해당 위치에 값을 삽입하는 알고리즘이다.

기본적인 로직은 다음과 같다.

1. Insertion sort는 두 번째 인덱스부터 시작한다. 현재 index는 별도의 변수에 저장해두고, 비교할 index를 현재 index-1로 둔다.
2. 별도로 저장한, 즉 insertion을 위한 값과 비교할 index에 해당하는 element 값을 비교한다.
3. insertion값이 더 작으면, 현재 인덱스로 비교할 element값을 저장, 비교 index를 -1하여 반복한다.
4. insertion 값이 더 크면, 비교 index + 1에 insertion값을 저장한다.

이 알고리즘은 역으로 정렬되어있을 때가 최악의 경우로, O(n^2)이지만 이미 정렬된 경우 한 번씩만 비교하기 때문에 O(n)이다. 하지만 Big-O notation은 상한을 기준으로 하므로 O(n^2)이다.

공간 복잡도는 하나의 배열에서 진행하므로 O(n)이다.

## Bubble Sort (버블 정렬)

Bubble sort는 매번 연속된 두 개의 인덱스 값에 해당하는 element의 값을 비교하여 작은 값을 앞으로, 큰 값을 뒤로 보내어 정렬하는 방법이다. (오름차순 정렬의 경우) 따라서 처음 한 번 이러한 과정을 수행하고 나면, 가장 큰 값이 맨 뒤에 저장된다. 그리고 다음에는 전체 배열의 크기에서 현재까지 순환한 횟수만큼만 반복해주면 된다.

기본적인 로직은 다음과 같다.

1. Bubble sort는 두 번째 인덱스부터 시작한다. 현재 인덱스와 다로 이전의 인덱스에 해당하는 element값을 비교한다.
2. 만약 이전의 값이 더 크면, 현재의 값과 바꾼다.
3. 현재 인덱스가 크면, 아무것도 하지 않는다.
4. 인덱스의 크기를 1 늘려준다.
5. 이를 전체 배열의 크기 - 현재 순환한 횟수만큼 반복한다

이 알고리즘은 selection sort와 마찬가지로 배열이 어떤 상태이건 전체 비교를 진행하므로 시간복잡도는 O(n^2)이다. 공간복잡도 역시 하나의 배열에서만 진행하므로 O(n)이다.

## Merge Sort (합병 정렬)

합병 정렬은 divide and conquer 방식으로 설계된 알고리즘이다. divide and conquer는 어떠한 문제를 나누어서 해결하는 방식인데, 여기서는 배열을 나눈 후에 Merge하는 방식을 택한다.

기본적인 로직은 다음과 같다.
1. 현재 배열을 반으로 나눈다. 배열의 시작 위치, 종료 위치를 각각 입력받고 둘을 더해 2로 나눈다. 이 값은 중간값으로 이를 기준으로 나누게 된다.
2. 이러한 방법을 통해서, 나누어진 배열의 크기가 0 혹은 1이 될때까지 반복한다.
3. 나누어진 두 배열 A,B의 크기를 비교한다. 각각의 배열에 대해서 현재 index를 i, j로 가정한다.
4. i에는 A배열의 시작 인덱스를 저장, j에는 B배열의 시작 인덱스를 저장한다.
5. A[i]와 B[j]를 비교한다. 오름차순의 경우 이 중에서 작은 값을 새 배열 C에 저장한다. A[i]가 더 크다면 A[i]를 배열 C에 저장해두고, i의 값을 하나 증가시켜준다.
6. 이를 i, j 둘 중 하나가 각 배열의 max index가 될 때 까지 반복한다.
7. 끝까지 저장 못한 배열의 값을 순서대로 C에 저장한다.
8. C를 원래 배열에 저장한다.

머지 과정에서는 A,B에 대한 정렬이 이루어지고, A배열의 크기를 n1, B배열의 크기를 n2라고 하면 O(n1+n2)가 된다. 즉 O(n)이 된다.

분할 과정은 Log(n)만큼 일어난다.

각 분할과정에 있어서 머지를 진행하므로, merge sort의 시간복잡도는 O(N * Log(n))이 된다. 사용하는 공간은 정렬을 위한 배열을 하나 더 생성하므로 2N개를 사용한다.

## Quick Sort (퀵 정렬)

Quick sort도 역시 Devide and conquer를 이용해 정렬을 수행하는 알고리즘이다. 퀵이라는 이름에서 알 수 있듯이 평균적으로 가장 좋은 성능을 보여준다. C, C++, PHP, Java등 거의 모든 언어의 standard library에서 제공하는 정렬 함수는 바로 이 퀵소트 혹은 퀵소트의 변형 알고리즘을 사용한다. 

방식은 'pivot'이라는 기준이 되는 값을 설정하고 이 값을 기준으로 작은 값은 왼쪽. 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다. 이를 반복하여 분할된 배열의 크기가 1이 되면 정렬이 완료된다.

기본적인 로직은 다음과 같다.
1. pivot point로 잡을 값 하나를 배열에서 정한다. 보통 맨 앞이나 맨 뒤, 혹은 중간 값이나 랜덤값으로 이를 정하기도 한다.
2. 분할을 진행하기 전에, 비교를 진행하기 위해 왼쪽 배열의 인덱스를 저장할 left변수와 오른쪽의 배열의 인덱스를 저장할 right변수를 생성한다.
3. right부터 비교를 진행한다. 비교는 right가 left보다 클 떄만 수행하며, 비교한 배열의 값이 pivot point의 값보다 크면 right를 하나 감소시키고 다시 비교를 수행한다.
4. right비교가 끝나면, left비교를 진행한다. 비교는 right가 left보다 클 때에 수행하며, 비교한 배열의 값이 pivot point보다 작으면 left를 하나 증가시키고 비교를 반복한다.
5. pivot point보다 큰 배열 값을 찾으면, 반복을 중지한다.
6. left 값과 right값을 바꿔준다
7. 3,4,5 과정을 left<right가 만족될 때 까지 반복한다.
8. 위의 과정이 끝나면 left와 pivot point를 바꾼다.
9 맨 왼쪽부터 left - 1까지, left + 1부터 맨 오른쪽까지 나눠 quick sort를 수행한다.

퀵소트는 분할과 동시에 정렬을 진행하는 알고리즘이다. 정렬하는데 배열의 크기 N만큼 비교하여, 이를 총 분할 깊이인 logN만큼 진행하므로, 총 비교횟수는 NlogN, 시간 복잡도는 O(logN)이다. 다만 퀵소트는 이미 정렬된 배열의 경우 분할이 N만큼 일어나게 되어 시간 복잡도는 O(N^2)이 된다. 이를 방지하기 위해, 앞에서 언급했던 전체 배열 값 중에서 중간값이나 랜덤값으로 pivot point를 정하는 방법을 사용하기도 한다.

최악의 경우 물론 merge sort보다 느리지만, 미리 정렬이 되어 있는 경우는 흔치 않다. 따라서 일반적으로 퀵소트보다 머지소트가 약 20% 빠르다는 연구 결과가 있다고 한다.

## Heap Sort (힙 정렬)

사실 힙소트는 selection sort와 거의 같은 알고리즘인데, 다만 가장 큰 원소를 뒤로 보내는 데 단순히 매번 쭉 돌면서 알아내느냐, 힙을 사용하여 알아내느냐가 차이점이라고 할 수 있다.

기본적인 알고리즘은 다음과 같다.
1. 원소들을 모두 힙에 삽입한다.
2. 힙의 루트에 있는 값은 남은 수들 중에서 최소값(혹은 최댓값)을 가지므로 루트에서 출력하고 힙에서 제거한다.
3. 힙이 빌때까지 2의 과정을 반복한다.
