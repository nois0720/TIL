## Endian

엔디언이라는 단어는 걸리버 여행기에서 등장했는데, 뭉툭한 끝(big-end)을 먼저 깨는 사람들(빅 엔디언)과 뾰족한 끝(little-end)을 먼저 깨는 사람들(리틀 엔디언) 사이에 격론이 벌어진 데서 따온 것이다.

Byte-order는 크게 위에서 언급한 빅 엔디언과 리틀 엔디언으로 나눌 수 있다. 빅 엔디언은 사람이 숫자를 쓰는 방법과 같이 큰 단위의 바이트가 앞에 오는 방법이고, 리틀 엔디언은 반대로 작은 단위의 바이트가 앞에 오는 방법이다. PDP-11과 같은 몇몇 아키텍처는 2바이트 단위와 1바이트 단위로 서로 다른 순서를 사용하기도 하는데 이들을 미들 엔디언이라 부른다. 다음은 이런 방법들을 비교한 것이다.

종류	0x1234의 표현	0x12345678의 표현
빅 엔디언	12 34	12 34 56 78
리틀 엔디언	34 12	78 56 34 12
미들 엔디언	-	34 12 78 56
또는
56 78 12 34

## MSB와 LSB

MSB는 Most Significant Bit, LSB는 Least Significant Bit의 약자이다. 다시 말해서 MSB는 가장 큰 자릿수의 비트를, LSB는 가장 작은 자릿수의 비트를 말한다. 예를 들어보자. 십진수 '192'는 이진수 '11000000'로 표현된다. 이진수 '11000000'의 MSB는 가장 왼쪽의 비트에 해당하는 값인 1이며 LSB는 가장 오른쪽에 있는 비트에 해당하는 값인 0이다.

만약 '11000000'을 리틀 엔디언식으로 표현하면 '00000011'이 된다. 따라서 리틀 엔디언의 LSB는 가장 오른쪽 비트인 '1'이며 빅 엔디언에서의 LSB는 '0'이다. 

## 네트워크에서의 엔디언

빅 엔디언과 리틀 엔디언은 둘 중 하나만 사용되는게 아니라, 여러 아키텍처에서 서로 공존하고 있다. 우리가 주로 사용하는 인텔 계열 CPU는 리틀 엔디안으로 데이터를 저장하고, ARM 계열에서는 빅 엔디언을 사용한다. 이렇듯 CPU에 따라서 메모리공간에 값을 저장하는 방식(Byte-order)이 다르다. 그럼 이렇게 byte-order가 다른 두 CPU가 데이터를 주고받을 때 발생할 수 있는 문제점은 무엇일까?

만약 빅 엔디언 시스템에서 0x12, 0x34의 조함으로 만들어지는 0x1234라는 값을 리틀 엔디언 시스템에게 전송한다고 하자. 그럼 리틀 엔디언 시스템에서는 0x12, 0x34순으로 데이터를 전송받아 0x1234가 아닌 0x3412로 데이터를 저장한다. 이러한 문제점을 해결하기 위해 네트워크를 통해서 데이터를 전송할 때에는 byte-order의 기준을 정하여 데이터를 전송하기로 약속하였고, 이 약속을 Network Byte Order라고 한다.

Network Byte Order는 Byte-Order를 빅 엔디언으로 쓴다. (역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다.) 때문에 모든 컴퓨터는 수신된 데이터가 Network Byte Order순으로 정렬되어있음을 인식하여 자신의 Byte-Order에 맞게 데이터를 정렬하여 사용해야한다.

## 장단점

빅 엔디언은 소프트웨어의 디버그를 편하게 해 주는 경향이 있다. 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리의 값을 보기 편한데, 예를 들어 0x59654148은 빅 엔디언으로 59 65 41 48로 표현된다.

반대로 리틀 엔디언은 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요 없다는 장점이 있다. 예를 들어, 32비트 숫자인 0x2A는 리틀 엔디언으로 표현하면 2A 00 00 00이 되는데, 이 표현에서 앞의 두 바이트 또는 한 바이트만 떼어 내면 하위 16비트 또는 8비트를 바로 얻을 수 있다. 반면 32비트 빅 엔디언 환경에서는 하위 16비트나 8비트 값을 얻기 위해서는 변수 주소에 2바이트 또는 3바이트를 더해야 한다. 보통 변수의 첫 바이트를 그 변수의 주소로 삼기 때문에 이런 성질은 종종 프로그래밍을 편하게 하는 반면, 리틀 엔디언 환경의 프로그래머가 빅 엔디언 환경에서 종종 실수를 일으키는 한 이유이기도 하다.

또한 가산기가 덧셈을 하는 과정은 LSB로부터 시작하여 자리 올림을 계산해야 하므로, 첫 번째 바이트가 LSB인 리틀 엔디언에서는 가산기 설계가 조금 더 단순해진다. 빅 엔디언에서는 가산기가 덧셈을 할때 마지막 바이트로부터 시작하여 첫 번째 바이트까지 역방향으로 진행해야 한다. 그러나 오늘날의 프로세서는 여러개의 바이트를 동시에 읽어들여 동시에 덧셈을 수행하는 구조를 갖고 있어 두 엔디언 사이에 사실상 차이가 없다.
