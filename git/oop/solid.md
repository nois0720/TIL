# SOLID - 객체지향 개발 5대 원리

우리들은 모두 어떠한 원리/원칙 아래에서 생활하고 있다. 그럼 우리는 왜 이런 원칙들 아래에서 생활하고 있는 걸까요? 답을 단정할 수는 없지만 아마도 그런 원칙들이 효율적이고 효과적이기 때문이다.

마찬가지로 객체지향 개발에 있어서도 검증된 디자인 원리를 사용하면 좀 더 유연하고 확장이 쉬운 소프트웨어를 만들 수 있다. 이 원리들은 패턴에 비하면 훨씬 그 규모가 작지만, 표준화부터 아키텍쳐 설계에 이르기까지 다양하게 적용되는 원칙이다. 

## 1. SRP (Single Responsibility Principle, 단일 책임의 원칙)

#### There should never be more than one reason for a class to change

### 정의

**작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어 있어야 한다는 원칙이다.** 이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 함을 의미한다. SRP원리를 적용하면 무엇보다도 책임의 영역이 명확해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있다. 뿐만 아니라 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이라는 이점까지 누릴 수 있으며 OCP(Open Close principle)원리뿐 아니라 다른 원리들을 적용하는 기초가 된다. 이 원리는 다른 원리들에 비해서 개념이 비교적 단순하지만, 이 원리를 적용해서 직접 클래스를 설계하기가 그리 쉽지만은 않다. 왜냐하면, 실무의 프로세스는 매우 복잡 다양하고 변경 또한 빈번하기 때문에 경험이 많지 않거나 도메인에 대한 이해가 부족하면 자신도 모르게 SRP원리에서 멀어져 버리게 된다. 따라서 평소에 많은 연습과 경험이 필요한 원칙이다.

### 적용 방법

책 리팩토링(Refactoring)에서 소개하는 대부분의 위험상황에 대한 해결방법은 직/간접적으로 SRP원리와 관련이 있으며, 이는 항상 코드를 최상으로 유지한다는 리팩토링의 근본정신도 항상 객체들의 책임을 최상의 상태로 분배한다는 것에서 비롯되기 때문이다.

* 여러 원인에 의한 변경 (Divergent change): Extract Class를 통해 혼재된 각 책임을 각각의 개별 클래스로 분할하여 클래스당 하나의 책임만을 맡도록 하는 것이다. 이 방법에서 가장 중요한 점은 책임만 분리하는 것이 아니라 분리된 두 클래스간의 관계의 복잡도를 줄이도록 설계하는 것이다. 만약 Extract Class된 각각의 클래스들이 유사하고 비슷한 책임을 중복해서 갖고 있다면 Extract Superclass를 사용할 수 있다. 이것은 Extract된 각각의 클래스들의 공유되는 요소를 부모 클래스로 정의하여 부모 클래스에 위임하는 기법이다. 따라서 각각의 Extract Class들의 유사한 책임들은 부모에게 명백히 위임하고 다른 책임들은 각자에게 정의할 수 있다.

* 산탄총 수술(Shotgun surgery): Move Field와 Move Method를 통해 책임을 기존의 어떤 클래스로 모으거나, 적당한 클래스가 없다면 새로운 클래스를 만들어 해결할 수 있다. 즉 산발적으로 여러 곳에 분포된 책임들을 한 곳에 모으면서 설계를 명확하게 한다. 한마디로 Cohesion(응집성)을 높이는 작업이다.

### 적용 사례

